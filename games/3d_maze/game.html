<!DOCTYPE html>
<html lang="en">
<head>
    <title>Procedurally Generated Maze with Player-Oriented Movement</title>
    <style>
        body { margin: 0; overflow: hidden; }
        canvas { display: block; }

        #blocker {
            position: absolute;
            top: 0;
            left: 0;
            background-color: rgba( 0, 0, 0, 0.5 );
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            z-index: 3; /* Ensure blocker is below the gameOverModal */
        }

        #instructions {
            font-size: 40px;
            color: #ffffff;
            text-align: center;
        }

        #minimap {
            position: absolute;
            top: 10px;
            right: 10px;
            width: 200px;
            height: 200px;
            border: 2px solid #000;
            background-color: rgba(255, 255, 255, 0.8);
            z-index: 1;
        }

        #minimap canvas {
            width: 100%;
            height: 100%;
        }

        #hud {
            position: absolute;
            top: 10px;
            left: 10px;
            color: #000000;
            font-size: 20px;
            z-index: 2;
            text-shadow: 1px 1px 2px #fff;
        }

        /* Modal Styles */
        #gameOverModal {
            position: fixed;
            z-index: 4; /* Ensure modal is above all other elements */
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            overflow: auto;
            background-color: rgba(0,0,0,0.8);
            display: none;
            align-items: center;
            justify-content: center;
            pointer-events: auto; /* Ensure modal can receive pointer events */
        }

        #gameOverContent {
            background-color: #fff;
            padding: 20px;
            text-align: center;
            border-radius: 10px;
            max-width: 80%;
            box-shadow: 0 0 10px rgba(0,0,0,0.5);
        }

        #gameOverContent p {
            font-size: 24px;
            margin-bottom: 20px;
        }

        #restartButton {
            padding: 10px 20px;
            font-size: 18px;
            cursor: pointer;
        }
    </style>
</head>
<body>
    <div id="blocker">
        <div id="instructions">
            Click to play<br>
            Use W to move forward, A to strafe left, D to strafe right<br>
            Move the mouse to look around<br>
            Press "Q" to reveal/hide the entire map<br>
            Hold "Shift" to move faster
        </div>
    </div>
    <div id="minimap">
        <canvas id="minimapCanvas" width="200" height="200"></canvas>
    </div>
    <div id="hud">
        <div id="level">Level: 1</div>
        <div id="score">Score: 0</div>
    </div>

    <!-- Game Over Modal -->
    <div id="gameOverModal">
        <div id="gameOverContent">
            <p id="gameOverMessage"></p>
            <button id="restartButton">Restart Game</button>
        </div>
    </div>

    <!-- Three.js Library -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>

        var camera, scene, renderer;
        var controlsEnabled = false;
        var moveForward = false;
        var moveLeft = false;
        var moveRight = false;
        var revealMap = false;

        var boost = false; // **Flag to track if Shift is pressed**

        var prevTime = performance.now();
        var velocity = new THREE.Vector3();
        var direction = new THREE.Vector3();

        var blocker = document.getElementById( 'blocker' );
        var instructions = document.getElementById( 'instructions' );

        var objects = [];
        var wallBoundingBoxes = [];

        var exitCube;
        var exitBoundingBox;
        var exitLight; // **Point light for the exit cube**

        var mazeSize = 51; // Should be odd for better room placement
        var cellSize = 5; // Smaller cell size for rooms and hallways

        var yawObject, pitchObject;

        // Minimap variables
        var minimapCanvas = document.getElementById('minimapCanvas');
        var minimapContext = minimapCanvas.getContext('2d');
        var minimapScale = minimapCanvas.width / (mazeSize * cellSize);

        // Maze data
        var maze = [];

        // Visited cells tracking
        var visitedCells = [];

        // Level and Score variables
        var level = 1; // Initialize level
        var baseZombieCount = 5; // Base number of zombies per level
        var score = 0; // Initialize score

        // Game state variables
        var gamePaused = false; // To control the game loop
        var totalTimeSurvived = 0; // Total time the player has survived

        // Current maximum number of rooms
        var currentMaxRooms = 5; // Start with 5 rooms

        // Day-Night Cycle variables
        var dayNightCycleTime = 0; // Time within the current day-night cycle
        var dayNightCycleDuration = 120; // Duration of the day-night cycle in seconds (2 minutes)

        var ambientLight, directionalLight;

        // **Initialize Projectiles and Zombies Arrays**
        var projectiles = [];
        var zombies = [];

        // **Added: Minimum spawn distance for zombies**
        var MIN_SPAWN_DISTANCE = 20; // Adjust as needed

        init();

        function init() {

            camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 1000 );

            scene = new THREE.Scene();
            scene.background = new THREE.Color( 0x87CEEB ); // Default sky color (daytime sky blue)

            // Add ambient light
            ambientLight = new THREE.AmbientLight( 0xFFFFFF, 0.5 ); // Soft white light
            scene.add( ambientLight );

            // Add directional light to cast shadows
            directionalLight = new THREE.DirectionalLight( 0xFFFFFF, 1.0 );
            directionalLight.position.set( 50, 50, 50 );
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 1024;
            directionalLight.shadow.mapSize.height = 1024;
            directionalLight.shadow.camera.near = 0.5;
            directionalLight.shadow.camera.far = 500;
            scene.add( directionalLight );

            // Set up shadow properties for the directional light
            directionalLight.shadow.camera.left = -100;
            directionalLight.shadow.camera.right = 100;
            directionalLight.shadow.camera.top = 100;
            directionalLight.shadow.camera.bottom = -100;

            // **Updated Floor Material:** Use MeshStandardMaterial with Green Color
            var floorGeometry = new THREE.PlaneGeometry( mazeSize * cellSize, mazeSize * cellSize );
            var floorMaterial = new THREE.MeshStandardMaterial( { 
                color: 0x006400,        // Dark Green color
                roughness: 0.8,          // Increased roughness for a matte finish
                metalness: 0.0           // Reduced metalness to eliminate metallic reflections
            } ); // Green floor
            var floor = new THREE.Mesh( floorGeometry, floorMaterial );
            floor.rotation.x = - Math.PI / 2;
            floor.receiveShadow = true;
            scene.add( floor );

            // Generate procedural maze with random rooms and hallways
            generateMaze( mazeSize, cellSize );

            function onKeyDown( event ) {
                switch ( event.code ) {

                    case 'KeyW':
                        moveForward = true;
                        break;

                    case 'KeyA':
                        moveLeft = true;
                        break;

                    case 'KeyD':
                        moveRight = true;
                        break;

                    case 'KeyQ':
                        revealMap = !revealMap;
                        break;

                    case 'ShiftLeft': // **Handle Left Shift**
                    case 'ShiftRight': // **Handle Right Shift**
                        boost = true;
                        break;
                }
            }

            function onKeyUp( event ) {
                switch ( event.code ) {

                    case 'KeyW':
                        moveForward = false;
                        break;

                    case 'KeyA':
                        moveLeft = false;
                        break;

                    case 'KeyD':
                        moveRight = false;
                        break;

                    case 'ShiftLeft': // **Handle Left Shift**
                    case 'ShiftRight': // **Handle Right Shift**
                        boost = false;
                        break;
                }
            }

            document.addEventListener( 'keydown', onKeyDown, false );
            document.addEventListener( 'keyup', onKeyUp, false );

            // **Add Mouse Down Event Listener for Firing Projectiles**
            document.addEventListener( 'mousedown', onMouseDown, false );

            // Pointer lock controls
            document.body.addEventListener( 'click', function () {

                document.body.requestPointerLock();

            }, false );

            document.addEventListener( 'pointerlockchange', onPointerLockChange, false );
            document.addEventListener( 'pointerlockerror', onPointerLockError, false );

            function onPointerLockChange() {

                if ( document.pointerLockElement === document.body ) {

                    controlsEnabled = true;
                    blocker.style.display = 'none';

                } else {

                    controlsEnabled = false;
                    blocker.style.display = 'flex';

                }

            }

            function onPointerLockError() {
                instructions.style.display = '';
            }

            pitchObject = new THREE.Object3D();
            pitchObject.add( camera );

            yawObject = new THREE.Object3D();
            yawObject.position.y = 2; // Adjust the player's height
            // Set player's starting position in a random room
            var startPos = getRandomOpenCell();
            yawObject.position.x = ( startPos.x - mazeSize / 2 ) * cellSize + cellSize / 2;
            yawObject.position.z = ( startPos.y - mazeSize / 2 ) * cellSize + cellSize / 2;
            yawObject.add( pitchObject );
            scene.add( yawObject );

            // Create a small box to represent the player for shadow casting
            var playerGeometry = new THREE.BoxGeometry( 1, 2, 1 );
            var playerMaterial = new THREE.MeshLambertMaterial( { color: 0x0000ff } );
            var playerMesh = new THREE.Mesh( playerGeometry, playerMaterial );
            playerMesh.position.y = 1; // Half of player's height
            playerMesh.castShadow = true;
            playerMesh.material.transparent = true;
            playerMesh.material.opacity = 0; // Make the player mesh invisible
            yawObject.add( playerMesh );

            document.addEventListener( 'mousemove', onMouseMove, false );

            function onMouseMove( event ) {

                if ( controlsEnabled === false ) return;
                if ( gamePaused ) return;

                var movementX = event.movementX || event.mozMovementX || event.webkitMovementX || 0;
                var movementY = event.movementY || event.mozMovementY || event.webkitMovementY || 0;

                yawObject.rotation.y -= movementX * 0.002;
                pitchObject.rotation.x -= movementY * 0.002;

                pitchObject.rotation.x = Math.max( - Math.PI / 2, Math.min( Math.PI / 2, pitchObject.rotation.x ) );

            }

            renderer = new THREE.WebGLRenderer( { antialias: true } );
            renderer.setSize( window.innerWidth, window.innerHeight );
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.body.appendChild( renderer.domElement );

            window.addEventListener( 'resize', onWindowResize, false );

            function onWindowResize() {

                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();

                renderer.setSize( window.innerWidth, window.innerHeight );

            }

            var playerBoundingBox = new THREE.Box3( new THREE.Vector3(), new THREE.Vector3() );

            // **Projectile Class Definition**
            function Projectile(position, direction) {
                var geometry = new THREE.SphereGeometry(0.2, 8, 8);
                var material = new THREE.MeshBasicMaterial({ color: 0xff0000 });
                this.mesh = new THREE.Mesh(geometry, material);
                this.mesh.position.copy(position);
                this.velocity = direction.clone().multiplyScalar(100); // Adjust speed as needed
                this.lifetime = 5; // Projectile lasts for 5 seconds
                scene.add(this.mesh);
            }

            // **Zombie Class Definition**
            function Zombie(position) {
                var geometry = new THREE.BoxGeometry(1, 2, 1);
                var material = new THREE.MeshLambertMaterial({ color: 0x00ff00 }); // Green zombies
                this.mesh = new THREE.Mesh(geometry, material);
                this.mesh.position.copy(position);
                this.mesh.castShadow = true;
                this.mesh.receiveShadow = true;

                this.speed = 10; // Slow movement speed

                this.path = []; // Array of waypoints (positions)
                this.currentWaypoint = 0;

                // **New Properties for Path Updating**
                this.pathUpdateTimer = 0;
                this.pathUpdateInterval = 1; // Update path every 1 second

                scene.add(this.mesh);
            }

            // **A* Pathfinding Implementation**
            function findPath(start, end, mazeArray) {
                var openSet = [];
                var closedSet = [];
                var cameFrom = {};

                function heuristic(a, b) {
                    return Math.abs(a.x - b.x) + Math.abs(a.y - b.y);
                }

                openSet.push({ x: start.x, y: start.y, f: heuristic(start, end), g: 0 });

                while (openSet.length > 0) {
                    // Find the node in openSet with the lowest f score
                    var currentIndex = 0;
                    for (var i = 1; i < openSet.length; i++) {
                        if (openSet[i].f < openSet[currentIndex].f) {
                            currentIndex = i;
                        }
                    }

                    var current = openSet[currentIndex];

                    if (current.x === end.x && current.y === end.y) {
                        // Reconstruct path
                        var path = [];
                        var key = current.x + "," + current.y;
                        while (key in cameFrom) {
                            var parts = key.split(",");
                            path.push({ x: parseInt(parts[0]), y: parseInt(parts[1]) });
                            key = cameFrom[key];
                        }
                        path.reverse();
                        return path;
                    }

                    openSet.splice(currentIndex, 1);
                    closedSet.push(current.x + "," + current.y);

                    // Explore neighbors
                    var neighbors = [
                        { x: current.x + 1, y: current.y },
                        { x: current.x - 1, y: current.y },
                        { x: current.x, y: current.y + 1 },
                        { x: current.x, y: current.y - 1 }
                    ];

                    for (var i = 0; i < neighbors.length; i++) {
                        var neighbor = neighbors[i];
                        var neighborKey = neighbor.x + "," + neighbor.y;

                        // Check bounds
                        if (neighbor.x < 0 || neighbor.x >= mazeSize || neighbor.y < 0 || neighbor.y >= mazeSize) continue;

                        // Check if wall
                        if (mazeArray[neighbor.x][neighbor.y] === 1) continue;

                        // Check if in closedSet
                        if (closedSet.indexOf(neighborKey) !== -1) continue;

                        var tentative_g = current.g + 1;

                        // Check if neighbor is in openSet
                        var existing = openSet.find(node => node.x === neighbor.x && node.y === neighbor.y);
                        if (existing) {
                            if (tentative_g < existing.g) {
                                existing.g = tentative_g;
                                existing.f = existing.g + heuristic(neighbor, end);
                                cameFrom[neighborKey] = current.x + "," + current.y;
                            }
                        } else {
                            openSet.push({
                                x: neighbor.x,
                                y: neighbor.y,
                                g: tentative_g,
                                f: tentative_g + heuristic(neighbor, end)
                            });
                            cameFrom[neighborKey] = current.x + "," + current.y;
                        }
                    }
                }

                // No path found
                return [];
            }

            function animate() {

                requestAnimationFrame( animate );

                if ( controlsEnabled && !gamePaused ) {

                    var time = performance.now();
                    var delta = ( time - prevTime ) / 1000;

                    // Update total time survived
                    totalTimeSurvived += delta;

                    // Update day-night cycle time
                    dayNightCycleTime = totalTimeSurvived % dayNightCycleDuration;

                    // Adjust lighting based on day-night cycle
                    updateLighting();

                    // **Modified:** Adjust movement speed based on boost
                    var baseSpeed = 40.0; // Slower default speed
                    var boostSpeed = 100.0; // Faster speed when Shift is held
                    var speed = boost ? boostSpeed * delta : baseSpeed * delta;

                    // Save previous position
                    var prevPosition = yawObject.position.clone();

                    // Compute forward and right vectors
                    var forward = new THREE.Vector3( 0, 0, -1 );
                    forward.applyQuaternion( yawObject.quaternion ).normalize();

                    var right = new THREE.Vector3( 1, 0, 0 );
                    right.applyQuaternion( yawObject.quaternion ).normalize();

                    // Build movement vector
                    var movement = new THREE.Vector3();

                    if ( moveForward ) movement.add( forward );
                    if ( moveLeft ) movement.sub( right );
                    if ( moveRight ) movement.add( right );

                    if ( movement.lengthSq() > 0 ) {
                        movement.normalize();
                        movement.multiplyScalar( speed );

                        // Attempt to move along X axis
                        yawObject.position.x += movement.x;

                        // Update player's bounding box
                        playerBoundingBox.setFromCenterAndSize( yawObject.position.clone(), new THREE.Vector3( 1.0, 2, 1.0 ) );

                        // Check for collisions in X direction
                        var collisionX = false;
                        for ( var i = 0; i < wallBoundingBoxes.length; i++ ) {
                            var wallBoundingBox = wallBoundingBoxes[ i ];

                            if ( playerBoundingBox.intersectsBox( wallBoundingBox ) ) {
                                // Collision detected in X direction, revert X position
                                yawObject.position.x = prevPosition.x;
                                collisionX = true;
                                break;
                            }
                        }

                        // Attempt to move along Z axis
                        yawObject.position.z += movement.z;

                        // Update player's bounding box
                        playerBoundingBox.setFromCenterAndSize( yawObject.position.clone(), new THREE.Vector3( 1.0, 2, 1.0 ) );

                        // Check for collisions in Z direction
                        var collisionZ = false;
                        for ( var i = 0; i < wallBoundingBoxes.length; i++ ) {
                            var wallBoundingBox = wallBoundingBoxes[ i ];

                            if ( playerBoundingBox.intersectsBox( wallBoundingBox ) ) {
                                // Collision detected in Z direction, revert Z position
                                yawObject.position.z = prevPosition.z;
                                collisionZ = true;
                                break;
                            }
                        }
                    }

                    // Rotate the exit cube
                    exitCube.rotation.y += 0.01;
                    exitCube.updateMatrixWorld( true );
                    exitCube.geometry.computeBoundingBox();
                    exitBoundingBox.copy( exitCube.geometry.boundingBox ).applyMatrix4( exitCube.matrixWorld );

                    // **Update exit light position**
                    if (exitLight) {
                        exitLight.position.copy(exitCube.position);
                    }

                    // Check for collision with exit cube
                    if ( playerBoundingBox.intersectsBox( exitBoundingBox ) ) {
                        // Player has reached the exit (level completed)
                        completeLevel();
                    }

                    // Update visited cells
                    updateVisitedCells();

                    // Update minimap
                    updateMinimap();

                    // **Update Projectiles**
                    updateProjectiles(delta);

                    // **Update Zombies**
                    updateZombies(delta);

                    // Update the HUD display
                    document.getElementById('level').textContent = 'Level: ' + level;
                    document.getElementById('score').textContent = 'Score: ' + score;

                    prevTime = time;

                }

                renderer.render( scene, camera );

            }

            animate();

            // Restart button event listener
            document.getElementById('restartButton').addEventListener('click', function() {
                restartGame();
            });

            // **Mouse Down Event Handler**
            function onMouseDown(event) {
                if (controlsEnabled && !gamePaused) {
                    if (event.button === 0) { // 0 is the left mouse button
                        // Get player's current position
                        var playerPosition = yawObject.position.clone();

                        // Get the direction the player is looking
                        var playerDirection = new THREE.Vector3(0, 0, -1);
                        playerDirection.applyQuaternion(yawObject.quaternion);

                        // Create a new projectile
                        var projectile = new Projectile(playerPosition, playerDirection);
                        projectiles.push(projectile);
                    }
                }
            }

            // **Update Projectiles Function**
            function updateProjectiles(delta) {
                for (var i = projectiles.length - 1; i >= 0; i--) {
                    var projectile = projectiles[i];

                    // Update projectile position
                    var movement = projectile.velocity.clone().multiplyScalar(delta);
                    projectile.mesh.position.add(movement);

                    // Decrease projectile's lifetime
                    projectile.lifetime -= delta;
                    if (projectile.lifetime <= 0) {
                        // Remove projectile from scene and array
                        scene.remove(projectile.mesh);
                        projectiles.splice(i, 1);
                        continue;
                    }

                    // Check for collisions with walls
                    var projectileBox = new THREE.Box3().setFromObject(projectile.mesh);
                    var collided = false;
                    for (var j = 0; j < wallBoundingBoxes.length; j++) {
                        if (projectileBox.intersectsBox(wallBoundingBoxes[j])) {
                            collided = true;
                            break;
                        }
                    }

                    if (collided) {
                        // Remove the projectile
                        scene.remove(projectile.mesh);
                        projectiles.splice(i, 1);
                    } else {
                        // Check for collisions with zombies
                        for (var z = zombies.length - 1; z >= 0; z--) {
                            var zombie = zombies[z];
                            var zombieBox = new THREE.Box3().setFromObject(zombie.mesh);
                            if (projectileBox.intersectsBox(zombieBox)) {
                                // Remove both projectile and zombie
                                scene.remove(projectile.mesh);
                                projectiles.splice(i, 1);

                                scene.remove(zombie.mesh);
                                zombies.splice(z, 1);

                                // Increment score
                                score += 1;
                                break; // Exit zombie loop since projectile is destroyed
                            }
                        }
                    }
                }
            }

            // **Zombie Spawning Mechanism**
            function spawnZombie() {
                var spawnPos;
                var attempts = 0;
                var maxAttempts = 100;
                var playerPos = yawObject.position.clone();

                do {
                    spawnPos = getRandomOpenCell();

                    // Convert maze grid position to world coordinates
                    var worldPos = new THREE.Vector3(
                        (spawnPos.x - mazeSize / 2) * cellSize + cellSize / 2,
                        1, // Half of zombie height
                        (spawnPos.y - mazeSize / 2) * cellSize + cellSize / 2
                    );

                    var distance = worldPos.distanceTo(playerPos);
                    attempts++;
                } while (distance < MIN_SPAWN_DISTANCE && attempts < maxAttempts);

                // If a suitable position wasn't found after maxAttempts, proceed anyway
                if (attempts >= maxAttempts && distance < MIN_SPAWN_DISTANCE) {
                    // Optionally, you can choose to not spawn the zombie
                    // return;
                }

                var zombie = new Zombie(worldPos);
                zombies.push(zombie);

                // Assign path to zombie
                assignPathToZombie(zombie);
            }

            // **Spawn Multiple Zombies for Current Level**
            function spawnZombiesForLevel() {
                var zombiesToSpawn = baseZombieCount + level * 2; // Increase zombies per level
                for (var i = 0; i < zombiesToSpawn; i++) {
                    spawnZombie();
                }
            }

            // **Assign Path to Zombie Using A* Pathfinding**
            function assignPathToZombie(zombie) {
                // Get player's current grid position
                var playerGridX = Math.floor( ( yawObject.position.x + ( mazeSize * cellSize ) / 2 ) / cellSize );
                var playerGridY = Math.floor( ( yawObject.position.z + ( mazeSize * cellSize ) / 2 ) / cellSize );

                // Get zombie's current grid position
                var zombieGridX = Math.floor( ( zombie.mesh.position.x + ( mazeSize * cellSize ) / 2 ) / cellSize );
                var zombieGridY = Math.floor( ( zombie.mesh.position.z + ( mazeSize * cellSize ) / 2 ) / cellSize );

                // Find path
                var path = findPath(
                    { x: zombieGridX, y: zombieGridY },
                    { x: playerGridX, y: playerGridY },
                    maze
                );

                // Convert path to world coordinates
                var worldPath = path.map(function(cell) {
                    return new THREE.Vector3(
                        (cell.x - mazeSize / 2) * cellSize + cellSize / 2,
                        1, // Half of zombie height
                        (cell.y - mazeSize / 2) * cellSize + cellSize / 2
                    );
                });

                zombie.path = worldPath;
                zombie.currentWaypoint = 0;
            }

            // **Zombie Movement Update Function**
            function updateZombies(delta) {
                for (var i = zombies.length - 1; i >= 0; i--) {
                    var zombie = zombies[i];

                    // **Increment Path Update Timer**
                    zombie.pathUpdateTimer += delta;
                    if (zombie.pathUpdateTimer >= zombie.pathUpdateInterval) {
                        assignPathToZombie(zombie);
                        zombie.pathUpdateTimer = 0;
                    }

                    // **Move Along the Current Path**
                    if (zombie.path.length > 0 && zombie.currentWaypoint < zombie.path.length) {
                        var target = zombie.path[zombie.currentWaypoint];
                        var targetPosition = target.clone();

                        // Calculate direction towards target
                        var direction = new THREE.Vector3();
                        direction.subVectors(targetPosition, zombie.mesh.position);
                        var distance = direction.length();

                        if (distance < 0.1) {
                            // Reached the current waypoint
                            zombie.currentWaypoint += 1;
                        } else {
                            direction.normalize();
                            // Move towards the target
                            var moveDistance = zombie.speed * delta;
                            if (moveDistance > distance) moveDistance = distance;
                            zombie.mesh.position.add(direction.multiplyScalar(moveDistance));
                        }
                    }

                    // **Check for Collision with Player**
                    var zombieBox = new THREE.Box3().setFromObject(zombie.mesh);
                    if (zombieBox.intersectsBox(playerBoundingBox)) {
                        // Player has been caught by a zombie
                        gameOver();
                        return;
                    }
                }

                // **Zombie Spawning Interval**
                // Removed redundant spawning inside updateZombies to avoid duplicate spawns
            }

            // **Generate Maze Function (Unchanged)**
            function generateMaze( mazeSize, cellSize ) {
                maze = createMazeWithRandomRooms( mazeSize );
                visitedCells = []; // Reset visited cells
                var wallMaterial = new THREE.MeshLambertMaterial( { color: 0x888888 } );

                // **Adjusted Wall Height:** Increased Y dimension from 5 to 10
                var wallGeometry = new THREE.BoxGeometry( cellSize, 10, cellSize ); // Changed height from 5 to 10
                for ( var i = 0; i < mazeSize; i++ ) {
                    visitedCells[ i ] = [];
                    for ( var j = 0; j < mazeSize; j++ ) {
                        visitedCells[ i ][ j ] = false; // Initialize visited cells
                        if ( maze[ i ][ j ] === 1 ) {
                            var wall = new THREE.Mesh( wallGeometry, wallMaterial );
                            wall.position.x = ( i - mazeSize / 2 ) * cellSize + cellSize / 2;
                            wall.position.y = 5; // Half of new wall height (10/2)
                            wall.position.z = ( j - mazeSize / 2 ) * cellSize + cellSize / 2;

                            wall.castShadow = true;
                            wall.receiveShadow = true;

                            wall.updateMatrixWorld( true );
                            wall.geometry.computeBoundingBox();
                            var wallBoundingBox = new THREE.Box3().setFromObject( wall );
                            wallBoundingBoxes.push( wallBoundingBox );

                            scene.add( wall );
                            objects.push( wall );
                        }
                    }
                }

                // Place the exit cube at a random open location
                var exitPos = getRandomOpenCell();
                // **Updated Material:** Use MeshStandardMaterial with emissive properties
                var exitGeometry = new THREE.BoxGeometry( cellSize / 2, cellSize / 2, cellSize / 2 );
                var exitMaterial = new THREE.MeshStandardMaterial( { 
                    color: 0xff0000, 
                    emissive: 0xff0000, 
                    emissiveIntensity: 1.5, // **Increased emissive intensity**
                    roughness: 0.5,
                    metalness: 0.5
                } );
                exitCube = new THREE.Mesh( exitGeometry, exitMaterial );

                exitCube.position.x = ( exitPos.x - mazeSize / 2 ) * cellSize + cellSize / 2;
                exitCube.position.y = cellSize / 4; // Half of its height (2.5 for cellSize=5)
                exitCube.position.z = ( exitPos.y - mazeSize / 2 ) * cellSize + cellSize / 2;

                exitCube.castShadow = true;
                exitCube.receiveShadow = true;

                exitCube.updateMatrixWorld( true );
                exitCube.geometry.computeBoundingBox();
                exitBoundingBox = new THREE.Box3().setFromObject( exitCube );

                scene.add( exitCube );

                // **Added:** Add a PointLight to make the exit cube glow
                exitLight = new THREE.PointLight(0xff0000, 2.0, 60); // **Increased intensity and distance**
                exitLight.position.copy(exitCube.position);
                exitLight.castShadow = false; // Disable shadow casting for the light to prevent performance issues
                scene.add(exitLight);
            }

            // **Remaining Functions (Unchanged)**
            function createMazeWithRandomRooms( size ) {
                var mazeArray = [];
                for ( var i = 0; i < size; i++ ) {
                    mazeArray[ i ] = [];
                    for ( var j = 0; j < size; j++ ) {
                        mazeArray[ i ][ j ] = 1; // Initialize all cells as walls
                    }
                }

                var maxRooms = currentMaxRooms; // Use currentMaxRooms instead of a fixed number
                var rooms = [];

                // Create rooms
                for ( var r = 0; r < maxRooms; r++ ) {
                    var roomWidth = getRandomOdd(3, 9); // Random odd number between 3 and 9
                    var roomHeight = getRandomOdd(3, 9);
                    var roomX = getRandomOdd(1, size - roomWidth - 1);
                    var roomY = getRandomOdd(1, size - roomHeight - 1);

                    var newRoom = { x: roomX, y: roomY, width: roomWidth, height: roomHeight };
                    var overlaps = false;

                    for ( var otherRoom of rooms ) {
                        if ( roomsOverlap( newRoom, otherRoom ) ) {
                            overlaps = true;
                            break;
                        }
                    }

                    if ( !overlaps ) {
                        createRoom( newRoom, mazeArray );
                        rooms.push( newRoom );
                    }
                }

                // Connect rooms with hallways
                for ( var i = 0; i < rooms.length - 1; i++ ) {
                    var roomA = rooms[ i ];
                    var roomB = rooms[ i + 1 ];
                    connectRooms( roomA, roomB, mazeArray );
                }

                // Ensure outer walls are solid
                for ( var i = 0; i < size; i++ ) {
                    mazeArray[ i ][ 0 ] = 1;
                    mazeArray[ i ][ size - 1 ] = 1;
                    mazeArray[ 0 ][ i ] = 1;
                    mazeArray[ size - 1 ][ i ] = 1;
                }

                return mazeArray;
            }

            function createRoom( room, mazeArray ) {
                for ( var i = room.x; i < room.x + room.width; i++ ) {
                    for ( var j = room.y; j < room.y + room.height; j++ ) {
                        mazeArray[ i ][ j ] = 0; // Mark as open space
                    }
                }
            }

            function connectRooms( roomA, roomB, mazeArray ) {
                var pointA = { x: getRandomInt( roomA.x + 1, roomA.x + roomA.width - 2 ), y: getRandomInt( roomA.y + 1, roomA.y + roomA.height - 2 ) };
                var pointB = { x: getRandomInt( roomB.x + 1, roomB.x + roomB.width - 2 ), y: getRandomInt( roomB.y + 1, roomB.y + roomB.height - 2 ) };

                // Randomly decide whether to go horizontal then vertical or vice versa
                if ( Math.random() < 0.5 ) {
                    carveHorizontalTunnel( mazeArray, pointA.x, pointB.x, pointA.y );
                    carveVerticalTunnel( mazeArray, pointA.y, pointB.y, pointB.x );
                } else {
                    carveVerticalTunnel( mazeArray, pointA.y, pointB.y, pointA.x );
                    carveHorizontalTunnel( mazeArray, pointA.x, pointB.x, pointB.y );
                }
            }

            function carveHorizontalTunnel( mazeArray, x1, x2, y ) {
                for ( var x = Math.min( x1, x2 ); x <= Math.max( x1, x2 ); x++ ) {
                    mazeArray[ x ][ y ] = 0;
                }
            }

            function carveVerticalTunnel( mazeArray, y1, y2, x ) {
                for ( var y = Math.min( y1, y2 ); y <= Math.max( y1, y2 ); y++ ) {
                    mazeArray[ x ][ y ] = 0;
                }
            }

            function roomsOverlap( roomA, roomB ) {
                return ( roomA.x <= roomB.x + roomB.width &&
                         roomA.x + roomA.width >= roomB.x &&
                         roomA.y <= roomB.y + roomB.height &&
                         roomA.y + roomA.height >= roomB.y );
            }

            function getRandomOdd( min, max ) {
                var num = Math.floor( Math.random() * ( ( max - min ) / 2 + 1 ) ) * 2 + min;
                if ( num % 2 === 0 ) num += 1;
                // Ensure the number is within bounds
                return Math.min( num, max - 1 );
            }

            function getRandomInt( min, max ) {
                return Math.floor( Math.random() * ( max - min + 1 ) ) + min;
            }

            function getRandomOpenCell() {
                var x, y;
                do {
                    x = getRandomInt( 1, mazeSize - 2 );
                    y = getRandomInt( 1, mazeSize - 2 );
                } while ( maze[ x ][ y ] !== 0 );
                return { x: x, y: y };
            }

            function completeLevel() {
                // Remove walls from the scene
                for ( var i = 0; i < objects.length; i++ ) {
                    scene.remove( objects[ i ] );
                }
                objects = [];
                wallBoundingBoxes = [];

                // Remove exit cube and its light
                scene.remove( exitCube );
                if (exitLight) {
                    scene.remove(exitLight);
                    exitLight = null;
                }

                // **Remove existing projectiles**
                for ( var p = 0; p < projectiles.length; p++ ) {
                    scene.remove(projectiles[p].mesh);
                }
                projectiles = [];

                // **Remove existing zombies**
                for ( var z = 0; z < zombies.length; z++ ) {
                    scene.remove(zombies[z].mesh);
                }
                zombies = [];

                // Increment the level
                level += 1;

                // Update the HUD with the new level
                document.getElementById('level').textContent = 'Level: ' + level;

                // Generate new maze (optionally increase complexity)
                generateMaze( mazeSize, cellSize );

                // Reset player's position
                var startPos = getRandomOpenCell();
                yawObject.position.set(
                    ( startPos.x - mazeSize / 2 ) * cellSize + cellSize / 2,
                    2,
                    ( startPos.y - mazeSize / 2 ) * cellSize + cellSize / 2
                );

                // Reset velocity
                velocity.set( 0, 0, 0 );

                // Spawn zombies based on the current level
                spawnZombiesForLevel();
            }

            function gameOver() {
                // **Release pointer lock to show the mouse cursor**
                document.exitPointerLock();

                // Display the game over modal
                document.getElementById('gameOverModal').style.display = 'flex';
                document.getElementById('gameOverMessage').textContent = 'You were caught by a zombie! You reached Level ' + level + ' with a score of ' + score + '.';
                gamePaused = true;
                controlsEnabled = false;

                // Optional: Focus the modal for accessibility
                document.getElementById('gameOverContent').focus();
            }

            function restartGame() {
                // Hide the game over modal
                document.getElementById('gameOverModal').style.display = 'none';

                // Reset game variables
                score = 0;
                level = 1;
                gamePaused = false;
                controlsEnabled = false; // Will be set to true upon pointer lock

                // Update the HUD
                document.getElementById('level').textContent = 'Level: ' + level;
                document.getElementById('score').textContent = 'Score: ' + score;

                // Remove walls from the scene
                for ( var i = 0; i < objects.length; i++ ) {
                    scene.remove( objects[ i ] );
                }
                objects = [];
                wallBoundingBoxes = [];

                // Remove exit cube and its light
                scene.remove( exitCube );
                if (exitLight) {
                    scene.remove(exitLight);
                    exitLight = null;
                }

                // **Remove existing projectiles**
                for ( var p = 0; p < projectiles.length; p++ ) {
                    scene.remove(projectiles[p].mesh);
                }
                projectiles = [];

                // **Remove existing zombies**
                for ( var z = 0; z < zombies.length; z++ ) {
                    scene.remove(zombies[z].mesh);
                }
                zombies = [];

                // Reset the number of rooms to starting value
                currentMaxRooms = 5;

                // Generate new maze
                generateMaze( mazeSize, cellSize );

                // Reset player's position
                var startPos = getRandomOpenCell();
                yawObject.position.set(
                    ( startPos.x - mazeSize / 2 ) * cellSize + cellSize / 2,
                    2,
                    ( startPos.y - mazeSize / 2 ) * cellSize + cellSize / 2
                );

                // Reset velocity
                velocity.set( 0, 0, 0 );

                // Spawn initial zombies
                spawnZombiesForLevel();

                // Reset totalTimeSurvived
                totalTimeSurvived = 0;

                // Reset day-night cycle time
                dayNightCycleTime = 0;

                // Reset pointer lock by prompting the user to click again
                instructions.style.display = '';
                blocker.style.display = 'flex';
            }

            function updateVisitedCells() {
                var x = Math.floor( ( yawObject.position.x + ( mazeSize * cellSize ) / 2 ) / cellSize );
                var z = Math.floor( ( yawObject.position.z + ( mazeSize * cellSize ) / 2 ) / cellSize );
                if ( x >= 0 && x < mazeSize && z >= 0 && z < mazeSize ) {
                    visitedCells[ x ][ z ] = true;
                }
            }

            function updateMinimap() {
                // Clear the minimap
                minimapContext.clearRect( 0, 0, minimapCanvas.width, minimapCanvas.height );

                // Determine which cells to draw
                for ( var i = 0; i < mazeSize; i++ ) {
                    for ( var j = 0; j < mazeSize; j++ ) {
                        if ( revealMap || visitedCells[ i ][ j ] ) {
                            // Draw floor
                            minimapContext.fillStyle = '#eee';
                            minimapContext.fillRect( i * cellSize * minimapScale, j * cellSize * minimapScale, cellSize * minimapScale, cellSize * minimapScale );

                            // Draw walls
                            if ( maze[ i ][ j ] === 1 ) {
                                minimapContext.fillStyle = '#000';
                                minimapContext.fillRect( i * cellSize * minimapScale, j * cellSize * minimapScale, cellSize * minimapScale, cellSize * minimapScale );
                            }
                        } else {
                            // If not revealed, fill with background color
                            minimapContext.fillStyle = '#aaa';
                            minimapContext.fillRect( i * cellSize * minimapScale, j * cellSize * minimapScale, cellSize * minimapScale, cellSize * minimapScale );
                        }
                    }
                }

                // Always draw the exit
                minimapContext.fillStyle = '#f00';
                minimapContext.fillRect(
                    ( ( exitCube.position.x + ( mazeSize * cellSize ) / 2 ) / cellSize ) * cellSize * minimapScale,
                    ( ( exitCube.position.z + ( mazeSize * cellSize ) / 2 ) / cellSize ) * cellSize * minimapScale,
                    cellSize * minimapScale,
                    cellSize * minimapScale
                );

                // Draw the player
                minimapContext.fillStyle = '#00f';
                var playerX = ( yawObject.position.x + ( mazeSize * cellSize ) / 2 ) * minimapScale;
                var playerZ = ( yawObject.position.z + ( mazeSize * cellSize ) / 2 ) * minimapScale;
                minimapContext.beginPath();
                minimapContext.arc( playerX, playerZ, 5, 0, 2 * Math.PI );
                minimapContext.fill();

                // Draw zombies
                minimapContext.fillStyle = '#0f0';
                for ( var z = 0; z < zombies.length; z++ ) {
                    var zombieX = ( zombies[z].mesh.position.x + ( mazeSize * cellSize ) / 2 ) * minimapScale;
                    var zombieZ = ( zombies[z].mesh.position.z + ( mazeSize * cellSize ) / 2 ) * minimapScale;
                    minimapContext.fillRect(zombieX - 2, zombieZ - 2, 4, 4);
                }
            }

            function updateLighting() {
                // Calculate the phase of the day-night cycle (from 0 to 1)
                var cyclePhase = (dayNightCycleTime % dayNightCycleDuration) / dayNightCycleDuration;

                // Calculate the angle for the sun's movement (from 0 to 2π)
                var sunAngle = cyclePhase * Math.PI * 2;

                // Update directional light position to simulate sun movement
                directionalLight.position.set(
                    Math.sin(sunAngle) * 50,
                    Math.cos(sunAngle) * 50,
                    directionalLight.position.z
                );

                // Calculate light intensity using cosine for smooth transitions
                var lightIntensity = Math.max(0, Math.cos(sunAngle));

                // Adjust directional light intensity
                directionalLight.intensity = lightIntensity;

                // Adjust ambient light intensity (less intense than directional light)
                ambientLight.intensity = 0.2 + 0.3 * lightIntensity;

                // Define sky colors
                var dayColor = new THREE.Color(0x87CEEB);      // Light Sky Blue
                var twilightColor = new THREE.Color(0xFFA07A); // Light Salmon
                var nightColor = new THREE.Color(0x0C1445);    // Deep Navy Blue

                var skyColor;

                if (lightIntensity > 0.5) {
                    // Interpolate between Twilight and Daytime
                    var t = (lightIntensity - 0.5) / 0.5; // Normalize t between 0 and 1
                    skyColor = twilightColor.clone().lerp(dayColor, t);
                } else if (lightIntensity > 0) {
                    // Interpolate between Nighttime and Twilight
                    var t = lightIntensity / 0.5; // Normalize t between 0 and 1
                    skyColor = nightColor.clone().lerp(twilightColor, t);
                } else {
                    // Night sky
                    skyColor = nightColor;
                }

                // Update the scene's background color
                scene.background = skyColor;
            }
        }
        </script>
    </body>
</html>
